Дочерняя нить не убивается раньше времени благодаря pthread_exit(NULL)

Поэтому в современных Unix-системах было введено понятие нитей (thread),
которые соответствуют единицам планирования в рамках одного процесса.
Нити разделяют общее адресное пространство, но планируются независимо. 
Иллюзия последовательного исполнения создается для нити, а не для процесса в целом.



Зачем нужны многопоточные программы

Улучшение времени реакции интерактивных программ.
Улучшение времени реакции серверных приложений. Возможность обрабатывать несколько запросов одновременно.
Использование дополнительных ресурсов на многопроцессорных и гипертрединговых компьютерах.
Задачи реального времени


Проблема пользовательских нитей:
    Если какая-то из нитей процесса исполняет блокирующийся системный вызов,
    блокируется весь процесс.
    Устранение этой проблемы требует серьезных изменений в механизме взаимодействия
    диспетчера системных вызовов с планировщиком операционной системы.
    То есть главное достоинство пользовательского планировщика при этом будет утеряно.

    Другим недостатком пользовательских нитей является то, что они не могут воспользоваться
    несколькими процессорами на однопроцессорной машине – ведь процесс всегда планируется
    только на одном процессоре!


Параметры pthread_create():

pthread_t * thread – Выходной параметр. Указатель на переменную, в которой при успешном завершении будет размещен идентификатор нити.
const pthread_attr_t * attr – Входной параметр. Указатель на структуру, в которой заданы атрибуты нити (рассматривается на следующей лекции). Если этот указатель равен NULL, используются атрибуты по умолчанию.
void *(*start_routine)(void*) – Входной параметр. Указатель на функцию, которая будет запущена во вновь созданной нити.
void * arg – Входной параметр. Значение, которое будет передано в качестве параметра start_routine.


Возвращаемое значение
0 при успешном завершении
Код ошибки при неудачном завершении



Параметр функции нити описан как void *,
но библиотека никогда не пытается обращаться к нему как к указателю.
Поэтому этот указатель можно использовать либо как ссылку на структуру (блок параметров нити),
либо для передачи скалярного значения.


    // printf("(1)Uno\n");
    // printf("(2)Dos\n");
    // printf("(3)Tres\n");
    // printf("(4)Cuatro\n");
    // printf("(5)Cinco\n");
    // printf("(6)Seis\n");
    // printf("(7)Siete\n");
    // printf("(8)Ocho\n");
    // printf("(9)Nueve\n");
    // printf("(10)Diez\n");


В мобилках нельзя блокировать главный поток, тк он рисует интерфейс!
Дочерние потоки скачивают данные из интернета и т.д.

Задача планировщика - чтобы все потоки отработали равномерно
Контекст потока: стек и регистры

Потоки нужны чтобы в основном исполнять фоновую работу

В стеке хранится иерархя вызовов
